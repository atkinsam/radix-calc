ws
    = #quiet<[ \t\n\r]+>

dec_lit -> i64 = n:$([0-9] ([0-9] / "_")*) {
    i64::from_str_radix(n, 10).unwrap()
}

hex_lit -> i64 = "0x" n:$([0-9a-fA-F_]+) {
    i64::from_str_radix(&*n.replace("_", ""), 16).unwrap()
}

bin_lit -> i64 = "0b" n:$([01_]+) {
    i64::from_str_radix(&*n.replace("_", ""), 2).unwrap()
}

oct_lit -> i64 = "0o" n:$([0-7_]+) {
    i64::from_str_radix(&*n.replace("_", ""), 8).unwrap()
}

number -> i64 = ws* n:(hex_lit / oct_lit / bin_lit / dec_lit) ws* {
    n
}

// TODO I think there's probably a cleaner way to do this, but rust-peg is a
// little unclear what happens with parentheses sometimes and I'm not 100%
// solid with Rust yet [DJG 2017-05-28]
unary_expr -> i64 = un_op:($("~" / "-"))? n:number {
    match un_op {
        Some(u) => {
            match u {
                "~" => !n,
                "-" => -n,
                _ => panic!("unhandled un_op"),
            }
        },
        None => n,
    }
}

infix_arith -> i64 = #infix<unary_expr> {
    #L x "|" y  { x | y }

    #L x "^" y  { x ^ y }

    #L x "&" y  { x & y }

    #L x ">>" y { x >> y }
       x "<<" y { x << y }

    #L x "+" y  { x + y }
       x "-" y  { x - y }

    #L x "*" y  { x * y }
       x "/" y  { x / y }
       x "%" y  { x % y }

    #L x "**" y { x.pow(y as u32) }
}

pub expr -> i64 = infix_arith / unary_expr

// TODO add "~" unary op support
